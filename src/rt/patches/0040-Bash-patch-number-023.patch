From c24f00caa4e3e1d222db9a651c9e22359bd7f143 Mon Sep 17 00:00:00 2001
From: Thomas Braun <thomas.braun@byte-physics.de>
Date: Wed, 7 Jan 2015 18:13:07 +0100
Subject: [PATCH 40/40] Bash patch number 023

---
 msys/packages/bash/3.1/builtins/evalstring.c | 29 ++++++++++++++++++++++------
 msys/packages/bash/3.1/parse.y               | 10 ++++++++++
 msys/packages/bash/3.1/patchlevel.h          |  2 +-
 msys/packages/bash/3.1/shell.h               |  2 ++
 4 files changed, 36 insertions(+), 7 deletions(-)

diff --git a/msys/packages/bash/3.1/builtins/evalstring.c b/msys/packages/bash/3.1/builtins/evalstring.c
index bbef9a3..23fef99 100644
--- a/msys/packages/bash/3.1/builtins/evalstring.c
+++ b/msys/packages/bash/3.1/builtins/evalstring.c
@@ -43,6 +43,7 @@
 #include "../execute_cmd.h"
 #include "../redir.h"
 #include "../trap.h"
+#include "../bashintl.h"
 
 #if defined (HISTORY)
 #  include "../bashhist.h"
@@ -223,12 +224,25 @@ parse_and_execute (string, from_file, flags)
 	    {
 	      struct fd_bitmap *bitmap;
 
-	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+	      if (flags & SEVAL_FUNCDEF)
 		{
-		  internal_warning ("%s: ignoring function definition attempt", from_file);
-		  should_jump_to_top_level = 0;
-		  last_result = last_command_exit_value = EX_BADUSAGE;
-		  break;
+		  char *x;
+
+		  /* If the command parses to something other than a straight
+		     function definition, or if we have not consumed the entire
+		     string, or if the parser has transformed the function
+		     name (as parsing will if it begins or ends with shell
+		     whitespace, for example), reject the attempt */
+		  if (command->type != cm_function_def ||
+		      ((x = parser_remaining_input ()) && *x) ||
+		      (STREQ (from_file, command->value.Function_def->name->word) == 0))
+		    {
+		      internal_warning (_("%s: ignoring function definition attempt"), from_file);
+		      should_jump_to_top_level = 0;
+		      last_result = last_command_exit_value = EX_BADUSAGE;
+		      reset_parser ();
+		      break;
+		    }
 		}
 
 	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
@@ -288,7 +302,10 @@ parse_and_execute (string, from_file, flags)
 	      discard_unwind_frame ("pe_dispose");
 
 	      if (flags & SEVAL_ONECMD)
-		break;
+		{
+		  reset_parser ();
+		  break;
+		}
 	    }
 	}
       else
diff --git a/msys/packages/bash/3.1/parse.y b/msys/packages/bash/3.1/parse.y
index 36a8b5c..9137921 100644
--- a/msys/packages/bash/3.1/parse.y
+++ b/msys/packages/bash/3.1/parse.y
@@ -2127,6 +2127,16 @@ shell_ungetc (c)
     eol_ungetc_lookahead = c;
 }
 
+char *
+parser_remaining_input ()
+{
+  if (shell_input_line == 0)
+    return 0;
+  if (shell_input_line_index < 0 || shell_input_line_index >= shell_input_line_len)
+    return '\0';	/* XXX */
+  return (shell_input_line + shell_input_line_index);
+}
+
 #ifdef INCLUDE_UNUSED
 /* Back the input pointer up by one, effectively `ungetting' a character. */
 static void
diff --git a/msys/packages/bash/3.1/patchlevel.h b/msys/packages/bash/3.1/patchlevel.h
index 56cf9b6..bd890d4 100644
--- a/msys/packages/bash/3.1/patchlevel.h
+++ b/msys/packages/bash/3.1/patchlevel.h
@@ -25,6 +25,6 @@
    regexp `^#define[ 	]*PATCHLEVEL', since that's what support/mkversion.sh
    looks for to find the patch level (for the sccs version string). */
 
-#define PATCHLEVEL 22
+#define PATCHLEVEL 23
 
 #endif /* _PATCHLEVEL_H_ */
diff --git a/msys/packages/bash/3.1/shell.h b/msys/packages/bash/3.1/shell.h
index ec08688..ae2f1a0 100644
--- a/msys/packages/bash/3.1/shell.h
+++ b/msys/packages/bash/3.1/shell.h
@@ -159,5 +159,7 @@ typedef struct _sh_parser_state_t {
 } sh_parser_state_t;
 
 /* Let's try declaring these here. */
+extern char *parser_remaining_input __P((void));
+
 extern sh_parser_state_t *save_parser_state __P((sh_parser_state_t *));
 extern void restore_parser_state __P((sh_parser_state_t *));
-- 
2.1.0.msysgit.0.2.g8768113.dirty

